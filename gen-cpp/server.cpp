// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "FileStore.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <iostream>
#include <fstream>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

class FileStoreHandler : virtual public FileStoreIf {
 public:

  FileStoreHandler() = default;

  RFile file;
  RFileMetadata metadata;
  std::ofstream file_stream;

  void writeFile(const RFile &rFile) override {

    if (file.meta.version == 0) {
      metadata.version = rFile.meta.version;
      std::cout << "this executed " << metadata.version << std::endl;
    }
    file.content = rFile.content;
    this->metadata.filename = rFile.meta.filename;
    this->metadata.version += 1;

    this->file_stream.open(metadata.filename.c_str());
    file_stream << file.content;

    this->file.meta.version = metadata.version;

    std::cout << file.content << " " << metadata.filename << " " << file.meta.version << " " << metadata.version
              << std::endl;
    file_stream.close();
    printf("writeFile succeeded\n");
  }
//
//  void readFile(RFile &_return, const std::string &filename) {
//    // Your implementation goes here
//    printf("readFile\n");
//  }
//
//  void setFingertable(const std::vector<NodeID> &node_list) {
//    // Your implementation goes here
//    printf("setFingertable\n");
//  }
//
//  void findSucc(NodeID &_return, const std::string &key) {
//    // Your implementation goes here
//    printf("findSucc\n");
//  }
//
//  void findPred(NodeID &_return, const std::string &key) {
//    // Your implementation goes here
//    printf("findPred\n");
//  }
//
//  void getNodeSucc(NodeID &_return) {
//    // Your implementation goes here
//    printf("getNodeSucc\n");
//  }

};

//class FileStoreHandlerFactory : virtual public FileStoreIfFactory {
// public:
//  ~FileStoreHandlerFactory() override = default;
//  FileStoreIf *getHandler(const ::apache::thrift::TConnectionInfo &connInfo) override {
//    std::shared_ptr<TSocket> sock = std::dynamic_pointer_cast<TSocket>(connInfo.transport);
//    std::cout << "Incoming connection\n";
//    std::cout << "\tSocketInfo: " << sock->getSocketInfo() << "\n";
//    std::cout << "\tPeerHost: " << sock->getPeerHost() << "\n";
//    std::cout << "\tPeerAddress: " << sock->getPeerAddress() << "\n";
//    std::cout << "\tPeerPort: " << sock->getPeerPort() << "\n";
//    return new FileStoreHandler;
//  }
//  void releaseHandler(::shared::SharedServiceIf *handler) override {
//    delete handler;
//  }
//};

int main(int argc, char **argv) {
  int port = 9090;
  ::std::shared_ptr<FileStoreHandler> handler(new FileStoreHandler());
  ::std::shared_ptr<TProcessor> processor(new FileStoreProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  std::cout << "server is rolling on port 9090" << std::endl;
  server.serve();
  return 0;
}

